
R version 4.2.1 (2022-06-23) -- "Funny-Looking Kid"
Copyright (C) 2022 The R Foundation for Statistical Computing
Platform: x86_64-apple-darwin17.0 (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

[Previously saved workspace restored]

> source("IS_trendf_functions_Pereyra.R")

Attaching package: ‘expm’

The following object is masked from ‘package:Matrix’:

    expm

Loading required package: iterators
Loading required package: parallel
> load("covmat.Rdata")
> load("MC_pcm.Rdata")
> 
> iter_hmc <- 1e4
> lamb_coeff <- 0.001
> D_mat <- getD(k=1, n=1e2, x)   #  D matrix
> 
> output_hmc <- list()
> 
> parallel::detectCores()
[1] 8
> num_cores <- 4
> doParallel::registerDoParallel(cores = num_cores)
> 
> output_hmc <- foreach(b = 1:num_cores) %dopar% {
+ my.hmc <- myhmc(y, alpha_hat,sigma2_hat,k=1, grid=x,iter = iter_hmc,
+               eps_hmc = 0.015, L = 100)
+ 
+ px.hmc <- pxhmc(y, alpha_hat,sigma2_hat,k=1, grid=x,iter = iter_hmc,
+                                        eps_hmc = 0.0003, L = 100) 
+ 
+ hmc_chain <- my.hmc[[1]]
+ weights <- my.hmc[[2]]
+ pxhmc_chain <- px.hmc[[1]]
+ is_samp <- matrix(unlist(hmc_chain), nrow = iter_hmc, ncol = length(y))
+ is_wts <- as.numeric(unlist(weights))
+ wts_mean <- mean(exp(is_wts))
+ num <- is_samp*exp(is_wts)
+ sum_mat <- apply(num, 2, sum)
+ is_est <- sum_mat / sum(exp(is_wts))
+ input_mat <- cbind(num, exp(is_wts))  # input samples for mcse
+ Sigma_mat <- mcse.multi(input_mat)$cov  # estimated covariance matrix of the tuple
+ kappa_eta_mat <- cbind(diag(1/wts_mean, length(y)), is_est/wts_mean) # derivative of kappa matrix
+ 
+ asymp_covmat_is <- (kappa_eta_mat %*% Sigma_mat) %*% t(kappa_eta_mat) # IS asymptotic variance
+ 
+ asymp_covmat_pxhmc <- mcse.multi(pxhmc_chain)$cov   # PxMALA asymptotic variance
+ 
+ rel_ess <- (det(asymp_covmat_pxhmc)/det(asymp_covmat_is))^(1/length(y))
+ 
+ ##  Posterior mean
+ 
+ weight_mat <- matrix(0, nrow = iter_hmc, ncol = length(y))
+ for (i in 1:iter_hmc) {
+   weight_mat[i,] <- hmc_chain[i,]*exp(weights[i])
+ }
+ num_sum <- apply(weight_mat, 2, sum)
+ weights_sum <- sum(exp(weights))
+ post_mean <- num_sum/weights_sum
+ 
+ #  Quantile visualisation
+ 
+ augm_mat <- cbind(hmc_chain,weights)
+ 
+ upper_quant <- numeric(length = length(y))
+ lower_quant <- numeric(length = length(y))
+ post_med <- numeric(length = length(y))
+ signif_level <- 0.025
+ 
+ for (i in 1:length(y)) 
+ {
+   initial_mat <- quant(i, augm_mat)
+   mat_sum <- apply(initial_mat, 2, sum)
+   wts_prop <- initial_mat[,2]/mat_sum[2]
+   final_mat <- cbind(initial_mat[1,], cumsum(wts_prop))
+   lower_index <- min(which(final_mat[,2] >= signif_level))
+   upper_index <- min(which(final_mat[,2] >= (1 - signif_level)))
+   med_index <- min(which(final_mat[,2] >= 0.5))
+   upper_quant[i] <- initial_mat[upper_index,1]
+   lower_quant[i] <- initial_mat[lower_index,1]
+   post_med[i] <- initial_mat[med_index,1]
+ }
+ 
+ acc_rate_is <- my.hmc[[3]]
+ acc_rate_pxhmc <- px.hmc[[2]]
+ list(post_mean, post_med, asymp_covmat_is, asymp_covmat_pxhmc, 
+      upper_quant, lower_quant, rel_ess, acc_rate_is, acc_rate_pxhmc)
+ }
1000 0.0662NULL
1000 0.0665NULL
1000 0.0662NULL
1000 0.0663NULL
2000 0.1296NULL
2000 0.1305NULL
2000 0.1325NULL
2000 0.1342NULL
3000 0.198NULL
3000 0.1947NULL
3000 0.2019NULL
3000 0.2009NULL
4000 0.2627NULL
4000 0.2656NULL
4000 0.2697NULL
4000 0.2661NULL
5000 0.3334NULL
5000 0.3285NULL
5000 0.3364NULL
5000 0.3318NULL
6000 0.4014NULL
6000 0.3959NULL
6000 0.405NULL
6000 0.3997NULL
7000 0.4692NULL
7000 0.4616NULL
7000 0.471NULL
7000 0.4675NULL
8000 0.5376NULL
8000 0.5248NULL
8000 0.5315NULL
8000 0.5366NULL
9000 0.6051NULL
9000 0.5928NULL
9000 0.6027NULL
9000 0.596NULL
10000 0.6728NULL
[1] 0.6728
10000 0.6586NULL
[1] 0.6586
10000 0.6672NULL
[1] 0.6672
10000 0.6624NULL
[1] 0.6624
1000 0.0653NULL
1000 0.0682NULL
1000 0.07NULL
1000 0.0666NULL
2000 0.1343NULL
2000 0.1398NULL
2000 0.1397NULL
2000 0.135NULL
3000 0.2035NULL
3000 0.2101NULL
3000 0.206NULL
3000 0.2011NULL
4000 0.2705NULL
4000 0.278NULL
4000 0.2745NULL
4000 0.2655NULL
5000 0.3391NULL
5000 0.3419NULL
5000 0.3468NULL
5000 0.3358NULL
6000 0.4089NULL
6000 0.4104NULL
6000 0.4154NULL
6000 0.4056NULL
7000 0.4772NULL
7000 0.4793NULL
7000 0.4859NULL
7000 0.4724NULL
8000 0.5446NULL
8000 0.5441NULL
8000 0.5559NULL
8000 0.5411NULL
9000 0.6107NULL
9000 0.6161NULL
9000 0.6227NULL
9000 0.6086NULL
10000 0.6779NULL
[1] 0.6779
10000 0.682NULL
[1] 0.682
10000 0.6903NULL
[1] 0.6903
10000 0.6802NULL
[1] 0.6802
> 
> save(output_hmc, file = "output_hmc.Rdata")
> 
> proc.time()
    user   system  elapsed 
8655.822   16.975 2172.198 
