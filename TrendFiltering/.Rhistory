# Generate predictors (features)
X <- matrix(rnorm(n * p), ncol = p)
# Generate true coefficients
theta_true <- c(3, 2, 1, 0, 0)
# Generate response variable
y <- X %*% theta_true + rnorm(n)
lambda <- 1
iter <- 50
mu <- 1.99/(max(eigen(X%*%t(X))$values) + 0.001)
theta_start <- c(7,5000,3,9,1)
theta <- matrix(0, nrow = iter, ncol = length(theta_true))
S <- numeric(length = iter)
grad_fn <- function(mat, data, value)
{
grad = t(mat)%*%(mat%*%value - data)
return(grad)
}
prox_func <- function(u, lambda) {       ####  u is a vector
return(sign(u)*sapply(u, FUN=function(x) {max(abs(x)-lambda,0)}))
}
theta[1,] <- theta_start
for (i in 2:iter)
{
gradval <- grad_fn(X, y, theta[i-1,])
z <- prox_func(theta[i-1,] - mu*gradval, mu*lambda)
S1 <- max(max(abs(gradval)) - lambda, 0)
S2 <- abs(t(gradval)%*%theta[i-1,] - sum(abs(theta[i-1,])))
S[i] <- max(S1, S2)
theta[i,] <- z
}
iter_nos <- seq(1:iter)
plot(iter_nos, S, type = "l")
set.seed(123)
n <- 100  # Number of samples
p <- 5    # Number of features
# Generate predictors (features)
X <- matrix(rnorm(n * p), ncol = p)
# Generate true coefficients
theta_true <- c(3, 2, 1, 0, 0)
# Generate response variable
y <- X %*% theta_true + rnorm(n)
lambda <- 1
iter <- 50
mu <- 1.99/(max(eigen(X%*%t(X))$values) + 0.001)
theta_start <- c(7,5,3,9,1)
theta <- matrix(0, nrow = iter, ncol = length(theta_true))
S <- numeric(length = iter)
grad_fn <- function(mat, data, value)
{
grad = t(mat)%*%(mat%*%value - data)
return(grad)
}
prox_func <- function(u, lambda) {       ####  u is a vector
return(sign(u)*sapply(u, FUN=function(x) {max(abs(x)-lambda,0)}))
}
theta[1,] <- theta_start
for (i in 2:iter)
{
gradval <- grad_fn(X, y, theta[i-1,])
z <- prox_func(theta[i-1,] - mu*gradval, mu*lambda)
S1 <- max(max(abs(gradval)) - lambda, 0)
S2 <- abs(t(gradval)%*%theta[i-1,] - sum(abs(theta[i-1,])))
S[i] <- max(S1, S2)
theta[i,] <- z
}
iter_nos <- seq(1:iter)
plot(iter_nos, S, type = "l")
set.seed(123)
n <- 100  # Number of samples
p <- 5    # Number of features
# Generate predictors (features)
X <- matrix(rnorm(n * p), ncol = p)
# Generate true coefficients
theta_true <- c(3, 2, 1, 0, 0)
# Generate response variable
y <- X %*% theta_true + rnorm(n)
lambda <- 1
iter <- 500
mu <- 1.99/(max(eigen(X%*%t(X))$values) + 0.001)
theta_start <- c(7,5,3,9,1)
theta <- matrix(0, nrow = iter, ncol = length(theta_true))
S <- numeric(length = iter)
grad_fn <- function(mat, data, value)
{
grad = t(mat)%*%(mat%*%value - data)
return(grad)
}
prox_func <- function(u, lambda) {       ####  u is a vector
return(sign(u)*sapply(u, FUN=function(x) {max(abs(x)-lambda,0)}))
}
theta[1,] <- theta_start
for (i in 2:iter)
{
gradval <- grad_fn(X, y, theta[i-1,])
z <- prox_func(theta[i-1,] - mu*gradval, mu*lambda)
S1 <- max(max(abs(gradval)) - lambda, 0)
S2 <- abs(t(gradval)%*%theta[i-1,] - sum(abs(theta[i-1,])))
S[i] <- max(S1, S2)
theta[i,] <- z
}
iter_nos <- seq(1:iter)
plot(iter_nos, S, type = "l")
set.seed(123)
n <- 100  # Number of samples
p <- 5    # Number of features
# Generate predictors (features)
X <- matrix(rnorm(n * p), ncol = p)
# Generate true coefficients
theta_true <- c(3, 2, 1, 0, 0)
# Generate response variable
y <- X %*% theta_true + rnorm(n)
lambda <- 1
iter <- 200
mu <- 1.99/(max(eigen(X%*%t(X))$values) + 0.001)
theta_start <- c(7,5,3,9,1)
theta <- matrix(0, nrow = iter, ncol = length(theta_true))
S <- numeric(length = iter)
grad_fn <- function(mat, data, value)
{
grad = t(mat)%*%(mat%*%value - data)
return(grad)
}
prox_func <- function(u, lambda) {       ####  u is a vector
return(sign(u)*sapply(u, FUN=function(x) {max(abs(x)-lambda,0)}))
}
theta[1,] <- theta_start
for (i in 2:iter)
{
gradval <- grad_fn(X, y, theta[i-1,])
z <- prox_func(theta[i-1,] - mu*gradval, mu*lambda)
S1 <- max(max(abs(gradval)) - lambda, 0)
S2 <- abs(t(gradval)%*%theta[i-1,] - sum(abs(theta[i-1,])))
S[i] <- max(S1, S2)
theta[i,] <- z
}
iter_nos <- seq(1:iter)
plot(iter_nos, S, type = "l")
S
set.seed(123)
n <- 100  # Number of samples
p <- 5    # Number of features
# Generate predictors (features)
X <- matrix(rnorm(n * p), ncol = p)
# Generate true coefficients
theta_true <- c(3, 2, 1, 0, 0)
# Generate response variable
y <- X %*% theta_true + rnorm(n)
lambda <- 1
iter <- 500
mu <- 1.99/(max(eigen(X%*%t(X))$values) + 0.001)
theta_start <- c(7,5,3,9,1)
theta <- matrix(0, nrow = iter, ncol = length(theta_true))
S <- numeric(length = iter)
grad_fn <- function(mat, data, value)
{
grad = t(mat)%*%(mat%*%value - data)
return(grad)
}
prox_func <- function(u, lambda) {       ####  u is a vector
return(sign(u)*sapply(u, FUN=function(x) {max(abs(x)-lambda,0)}))
}
theta[1,] <- theta_start
for (i in 2:iter)
{
gradval <- grad_fn(X, y, theta[i-1,])
z <- prox_func(theta[i-1,] - mu*gradval, mu*lambda)
S1 <- max(max(abs(gradval)) - lambda, 0)
S2 <- abs(t(gradval)%*%theta[i-1,] - sum(abs(theta[i-1,])))
S[i] <- max(S1, S2)
theta[i,] <- z
}
iter_nos <- seq(1:iter)
plot(iter_nos, S, type = "l")
S
i <- 2
gradval <- grad_fn(X, y, theta[i-1,])
gradval
z <- prox_func(theta[i-1,] - mu*gradval, mu*lambda)
z
S1 <- max(max(abs(gradval)) - lambda, 0)
S1
S2 <- abs(t(gradval)%*%theta[i-1,] - sum(abs(theta[i-1,])))
S2
set.seed(123)
n <- 100  # Number of samples
p <- 5    # Number of features
# Generate predictors (features)
X <- matrix(rnorm(n * p), ncol = p)
# Generate true coefficients
theta_true <- c(3, 2, 1, 0, 0)
# Generate response variable
y <- X %*% theta_true + rnorm(n)
lambda <- 1
iter <- 500
mu <- 1.99/(max(eigen(X%*%t(X))$values) + 0.001)
theta_start <- c(7,5,3,9,1)
theta <- matrix(0, nrow = iter, ncol = length(theta_true))
S <- numeric(length = iter)
grad_fn <- function(mat, data, value)
{
grad = t(mat)%*%(mat%*%value - data)
return(grad)
}
prox_func <- function(u, lambda) {       ####  u is a vector
return(sign(u)*sapply(u, FUN=function(x) {max(abs(x)-lambda,0)}))
}
theta[1,] <- theta_start
for (i in 2:iter)
{
gradval <- grad_fn(X, y, theta[i-1,])
z <- prox_func(theta[i-1,] - mu*gradval, mu*lambda)
S1 <- max(max(abs(gradval)) - lambda, 0)
S2 <- abs(t(gradval)%*%theta[i-1,] - sum(abs(theta[i-1,])))
S[i-1] <- max(S1, S2)
theta[i,] <- z
}
iter_nos <- seq(1:iter)
plot(iter_nos, S, type = "l")
set.seed(123)
n <- 100  # Number of samples
p <- 5    # Number of features
# Generate predictors (features)
X <- matrix(rnorm(n * p), ncol = p)
# Generate true coefficients
theta_true <- c(3, 2, 1, 0, 0)
# Generate response variable
y <- X %*% theta_true + rnorm(n)
lambda <- 1
iter <- 50
mu <- 1.99/(max(eigen(X%*%t(X))$values) + 0.001)
theta_start <- c(7,5,3,9,1)
theta <- matrix(0, nrow = iter, ncol = length(theta_true))
S <- numeric(length = iter)
grad_fn <- function(mat, data, value)
{
grad = t(mat)%*%(mat%*%value - data)
return(grad)
}
prox_func <- function(u, lambda) {       ####  u is a vector
return(sign(u)*sapply(u, FUN=function(x) {max(abs(x)-lambda,0)}))
}
theta[1,] <- theta_start
for (i in 2:iter)
{
gradval <- grad_fn(X, y, theta[i-1,])
z <- prox_func(theta[i-1,] - mu*gradval, mu*lambda)
S1 <- max(max(abs(gradval)) - lambda, 0)
S2 <- abs(t(gradval)%*%theta[i-1,] - sum(abs(theta[i-1,])))
S[i-1] <- max(S1, S2)
theta[i,] <- z
}
iter_nos <- seq(1:iter)
plot(iter_nos, S, type = "l")
set.seed(123)
n <- 100  # Number of samples
p <- 5    # Number of features
# Generate predictors (features)
X <- matrix(rnorm(n * p), ncol = p)
# Generate true coefficients
theta_true <- c(3, 2, 1, 0, 0)
# Generate response variable
y <- X %*% theta_true + rnorm(n)
lambda <- 1
iter <- 50
mu <- 1.99/(max(eigen(X%*%t(X))$values) + 0.001)
theta_start <- c(7,5,3,9,1)
theta <- matrix(0, nrow = iter, ncol = length(theta_true))
S <- numeric(length = iter)
grad_fn <- function(mat, data, value)
{
grad = t(mat)%*%(mat%*%value - data)
return(grad)
}
prox_func <- function(u, lambda) {       ####  u is a vector
return(sign(u)*sapply(u, FUN=function(x) {max(abs(x)-lambda,0)}))
}
theta[1,] <- theta_start
for (i in 2:iter)
{
gradval <- grad_fn(X, y, theta[i-1,])
z <- prox_func(theta[i-1,] - mu*gradval, mu*lambda)
S1 <- max(max(abs(gradval)) - lambda, 0)
S2 <- abs(t(gradval)%*%theta[i-1,] - sum(abs(theta[i-1,])))
S[i-1] <- max(S1, S2)
theta[i,] <- z
}
iter_nos <- seq(1:iter)
plot(iter_nos, log(S), type = "l")
set.seed(123)
n <- 100  # Number of samples
p <- 5    # Number of features
# Generate predictors (features)
X <- matrix(rnorm(n * p), ncol = p)
# Generate true coefficients
theta_true <- c(3, 2, 1, 0, 0)
# Generate response variable
y <- X %*% theta_true + rnorm(n)
lambda <- 1
iter <- 500
mu <- 1.99/(max(eigen(X%*%t(X))$values) + 0.001)
theta_start <- c(7,5,3,9,1)
theta <- matrix(0, nrow = iter, ncol = length(theta_true))
S <- numeric(length = iter)
grad_fn <- function(mat, data, value)
{
grad = t(mat)%*%(mat%*%value - data)
return(grad)
}
prox_func <- function(u, lambda) {       ####  u is a vector
return(sign(u)*sapply(u, FUN=function(x) {max(abs(x)-lambda,0)}))
}
theta[1,] <- theta_start
for (i in 2:iter)
{
gradval <- grad_fn(X, y, theta[i-1,])
z <- prox_func(theta[i-1,] - mu*gradval, mu*lambda)
S1 <- max(max(abs(gradval)) - lambda, 0)
S2 <- abs(t(gradval)%*%theta[i-1,] - sum(abs(theta[i-1,])))
S[i-1] <- max(S1, S2)
theta[i,] <- z
}
iter_nos <- seq(1:iter)
plot(iter_nos, log(S), type = "l")
set.seed(123)
n <- 100  # Number of samples
p <- 5    # Number of features
# Generate predictors (features)
X <- matrix(rnorm(n * p), ncol = p)
# Generate true coefficients
theta_true <- c(3, 2, 1, 0, 0)
# Generate response variable
y <- X %*% theta_true + rnorm(n)
lambda <- 1
iter <- 500
mu <- 1.99/(max(eigen(X%*%t(X))$values) + 0.001)
theta_start <- c(7,5,3,9,1)
theta <- matrix(0, nrow = iter, ncol = length(theta_true))
S <- numeric(length = iter)
grad_fn <- function(mat, data, value)
{
grad = - t(mat)%*%(mat%*%value - data)
return(grad)
}
prox_func <- function(u, lambda) {       ####  u is a vector
return(sign(u)*sapply(u, FUN=function(x) {max(abs(x)-lambda,0)}))
}
theta[1,] <- theta_start
for (i in 2:iter)
{
gradval <- grad_fn(X, y, theta[i-1,])
z <- prox_func(theta[i-1,] - mu*gradval, mu*lambda)
S1 <- max(max(abs(gradval)) - lambda, 0)
S2 <- abs(t(gradval)%*%theta[i-1,] - sum(abs(theta[i-1,])))
S[i-1] <- max(S1, S2)
theta[i,] <- z
}
iter_nos <- seq(1:iter)
plot(iter_nos, log(S), type = "l")
View(x_tv_denoised)
set.seed(123)
n <- 100  # Number of samples
p <- 5    # Number of features
# Generate predictors (features)
X <- matrix(rnorm(n * p), ncol = p)
# Generate true coefficients
theta_true <- c(3, 2, 1, 0, 0)
# Generate response variable
y <- X %*% theta_true + rnorm(n)
lambda <- 1
iter <- 500
mu <- 1.99/(max(eigen(X%*%t(X))$values) + 0.001)
theta_start <- c(7,5,3,9,1)
theta <- matrix(0, nrow = iter, ncol = length(theta_true))
S <- numeric(length = iter)
grad_fn <- function(mat, data, value)
{
grad = t(mat)%*%(mat%*%value - data)
return(grad)
}
prox_func <- function(u, lambda) {       ####  u is a vector
return(sign(u)*sapply(u, FUN=function(x) {max(abs(x)-lambda,0)}))
}
theta[1,] <- theta_start
for (i in 2:iter)
{
gradval <- grad_fn(X, y, theta[i-1,])
z <- prox_func(theta[i-1,] - mu*gradval, mu*lambda)
S1 <- max(max(abs(gradval)) - lambda, 0)
S2 <- abs(-t(gradval)%*%theta[i-1,] - sum(abs(theta[i-1,])))
S[i-1] <- max(S1, S2)
theta[i,] <- z
}
iter_nos <- seq(1:iter)
plot(iter_nos, log(S), type = "l")
set.seed(123)
n <- 100  # Number of samples
p <- 5    # Number of features
# Generate predictors (features)
X <- matrix(rnorm(n * p), ncol = p)
# Generate true coefficients
theta_true <- c(3, 2, 1, 0, 0)
# Generate response variable
y <- X %*% theta_true + rnorm(n)
lambda <- 1
iter <- 500
mu <- 1.99/(max(eigen(X%*%t(X))$values) + 0.001)
theta_start <- c(7,5,3,9,1)
theta <- matrix(0, nrow = iter, ncol = length(theta_true))
S <- numeric(length = iter)
grad_fn <- function(mat, data, value)
{
grad = t(mat)%*%(mat%*%value - data)
return(grad)
}
prox_func <- function(u, lambda) {       ####  u is a vector
return(sign(u)*sapply(u, FUN=function(x) {max(abs(x)-lambda,0)}))
}
theta[1,] <- theta_start
for (i in 2:iter)
{
gradval <- grad_fn(X, y, theta[i-1,])
z <- prox_func(theta[i-1,] - mu*gradval, mu*lambda)
S1 <- max(max(abs(gradval)) - lambda, 0)
S2 <- abs(-t(gradval)%*%theta[i-1,] - sum(abs(theta[i-1,])))
S[i-1] <- max(S1, S2)
theta[i,] <- z
}
iter_nos <- seq(1:iter)
plot(iter_nos, S, type = "l")
S
set.seed(123)
n <- 100  # Number of samples
p <- 5    # Number of features
# Generate predictors (features)
X <- matrix(rnorm(n * p), ncol = p)
# Generate true coefficients
theta_true <- c(3, 2, 1, 0, 0)
# Generate response variable
y <- X %*% theta_true + rnorm(n)
lambda <- 1
iter <- 500
mu <- 1.99/(max(eigen(X%*%t(X))$values) + 0.001)
theta_start <- c(7,5,3,9,1)
theta <- matrix(0, nrow = iter, ncol = length(theta_true))
S <- numeric(length = iter)
grad_fn <- function(mat, data, value)
{
grad = t(mat)%*%(mat%*%value - data)
return(grad)
}
prox_func <- function(u, lambda) {       ####  u is a vector
return(sign(u)*sapply(u, FUN=function(x) {max(abs(x)-lambda,0)}))
}
theta[1,] <- theta_start
for (i in 2:iter)
{
gradval <- grad_fn(X, y, theta[i-1,])
z <- prox_func(theta[i-1,] - mu*gradval, mu*lambda)
S1 <- max(max(abs(gradval)) - lambda, 0)
S2 <- abs(-t(gradval)%*%theta[i-1,] - sum(abs(theta[i-1,])))
S[i-1] <- max(S1, S2)
theta[i,] <- z
}
iter_nos <- seq(1:iter)
plot(iter_nos, log(S), type = "l")
set.seed(123)
n <- 100  # Number of samples
p <- 5    # Number of features
# Generate predictors (features)
X <- matrix(rnorm(n * p), ncol = p)
# Generate true coefficients
theta_true <- c(3, 2, 1, 0, 0)
# Generate response variable
y <- X %*% theta_true + rnorm(n)
lambda <- 1
iter <- 500
mu <- 1.99/(max(eigen(X%*%t(X))$values) + 0.001)
theta_start <- c(7,5,3,9,1)
theta <- matrix(0, nrow = iter, ncol = length(theta_true))
S <- numeric(length = iter)
grad_fn <- function(mat, data, value)
{
grad = t(mat)%*%(mat%*%value - data)
return(grad)
}
prox_func <- function(u, lambda) {       ####  u is a vector
return(sign(u)*sapply(u, FUN=function(x) {max(abs(x)-lambda,0)}))
}
theta[1,] <- theta_start
for (i in 2:iter)
{
gradval <- grad_fn(X, y, theta[i-1,])
z <- prox_func(theta[i-1,] - mu*gradval, mu*lambda)
S1 <- max(max(abs(gradval)) - lambda, 0)
S2 <- abs(-t(gradval)%*%theta[i-1,] - sum(abs(theta[i-1,])))
S[i-1] <- max(S1, S2)
theta[i,] <- z
}
iter_nos <- seq(1:iter)
plot(iter_nos, S, type = "l")
setwd("~/Documents/GitHub/Proximal_IS/TrendFiltering")
source("TF_functions.R")
load("pcm_last_iter.Rdata")
iter_mala <- 1e4
lamb_coeff <- 0.001
D_mat <- getD(k=1, n=1e2, x)   #  D matrix
delta_samp_is <- 0.0015
delta_samp_pxm <- 0.0008
mala.is <- mymala(y, alpha_hat, sigma2_hat, k=1, grid=x, iter = iter_mala,
delta = delta_samp_is, start = pcm_last_iter)
pxmala.run <- px.mala(y, alpha_hat, sigma2_hat, k=1, grid=x, iter = iter_mala,
delta = delta_samp_pxm, start = pcm_last_iter)
