theta[i,] <- z
}
iter_nos <- seq(1:iter)
plot(iter_nos, S, type = "l")
set.seed(123)
n <- 100  # Number of samples
p <- 5    # Number of features
# Generate predictors (features)
X <- matrix(rnorm(n * p), ncol = p)
# Generate true coefficients
theta_true <- c(3, 2, 1, 0, 0)
# Generate response variable
y <- X %*% theta_true + rnorm(n)
lambda <- 1
iter <- 50
mu <- 1.99/(max(eigen(X%*%t(X))$values) + 0.001)
theta_start <- c(7,5,3,9,1)
theta <- matrix(0, nrow = iter, ncol = length(theta_true))
S <- numeric(length = iter)
grad_fn <- function(mat, data, value)
{
grad = t(mat)%*%(mat%*%value - data)
return(grad)
}
prox_func <- function(u, lambda) {       ####  u is a vector
return(sign(u)*sapply(u, FUN=function(x) {max(abs(x)-lambda,0)}))
}
theta[1,] <- theta_start
for (i in 2:iter)
{
gradval <- grad_fn(X, y, theta[i-1,])
z <- prox_func(theta[i-1,] - mu*gradval, mu*lambda)
S1 <- max(max(abs(gradval)) - lambda, 0)
S2 <- abs(t(gradval)%*%theta[i-1,] - sum(abs(theta[i-1,])))
S[i-1] <- max(S1, S2)
theta[i,] <- z
}
iter_nos <- seq(1:iter)
plot(iter_nos, S, type = "l")
set.seed(123)
n <- 100  # Number of samples
p <- 5    # Number of features
# Generate predictors (features)
X <- matrix(rnorm(n * p), ncol = p)
# Generate true coefficients
theta_true <- c(3, 2, 1, 0, 0)
# Generate response variable
y <- X %*% theta_true + rnorm(n)
lambda <- 1
iter <- 50
mu <- 1.99/(max(eigen(X%*%t(X))$values) + 0.001)
theta_start <- c(7,5,3,9,1)
theta <- matrix(0, nrow = iter, ncol = length(theta_true))
S <- numeric(length = iter)
grad_fn <- function(mat, data, value)
{
grad = t(mat)%*%(mat%*%value - data)
return(grad)
}
prox_func <- function(u, lambda) {       ####  u is a vector
return(sign(u)*sapply(u, FUN=function(x) {max(abs(x)-lambda,0)}))
}
theta[1,] <- theta_start
for (i in 2:iter)
{
gradval <- grad_fn(X, y, theta[i-1,])
z <- prox_func(theta[i-1,] - mu*gradval, mu*lambda)
S1 <- max(max(abs(gradval)) - lambda, 0)
S2 <- abs(t(gradval)%*%theta[i-1,] - sum(abs(theta[i-1,])))
S[i-1] <- max(S1, S2)
theta[i,] <- z
}
iter_nos <- seq(1:iter)
plot(iter_nos, log(S), type = "l")
set.seed(123)
n <- 100  # Number of samples
p <- 5    # Number of features
# Generate predictors (features)
X <- matrix(rnorm(n * p), ncol = p)
# Generate true coefficients
theta_true <- c(3, 2, 1, 0, 0)
# Generate response variable
y <- X %*% theta_true + rnorm(n)
lambda <- 1
iter <- 500
mu <- 1.99/(max(eigen(X%*%t(X))$values) + 0.001)
theta_start <- c(7,5,3,9,1)
theta <- matrix(0, nrow = iter, ncol = length(theta_true))
S <- numeric(length = iter)
grad_fn <- function(mat, data, value)
{
grad = t(mat)%*%(mat%*%value - data)
return(grad)
}
prox_func <- function(u, lambda) {       ####  u is a vector
return(sign(u)*sapply(u, FUN=function(x) {max(abs(x)-lambda,0)}))
}
theta[1,] <- theta_start
for (i in 2:iter)
{
gradval <- grad_fn(X, y, theta[i-1,])
z <- prox_func(theta[i-1,] - mu*gradval, mu*lambda)
S1 <- max(max(abs(gradval)) - lambda, 0)
S2 <- abs(t(gradval)%*%theta[i-1,] - sum(abs(theta[i-1,])))
S[i-1] <- max(S1, S2)
theta[i,] <- z
}
iter_nos <- seq(1:iter)
plot(iter_nos, log(S), type = "l")
set.seed(123)
n <- 100  # Number of samples
p <- 5    # Number of features
# Generate predictors (features)
X <- matrix(rnorm(n * p), ncol = p)
# Generate true coefficients
theta_true <- c(3, 2, 1, 0, 0)
# Generate response variable
y <- X %*% theta_true + rnorm(n)
lambda <- 1
iter <- 500
mu <- 1.99/(max(eigen(X%*%t(X))$values) + 0.001)
theta_start <- c(7,5,3,9,1)
theta <- matrix(0, nrow = iter, ncol = length(theta_true))
S <- numeric(length = iter)
grad_fn <- function(mat, data, value)
{
grad = - t(mat)%*%(mat%*%value - data)
return(grad)
}
prox_func <- function(u, lambda) {       ####  u is a vector
return(sign(u)*sapply(u, FUN=function(x) {max(abs(x)-lambda,0)}))
}
theta[1,] <- theta_start
for (i in 2:iter)
{
gradval <- grad_fn(X, y, theta[i-1,])
z <- prox_func(theta[i-1,] - mu*gradval, mu*lambda)
S1 <- max(max(abs(gradval)) - lambda, 0)
S2 <- abs(t(gradval)%*%theta[i-1,] - sum(abs(theta[i-1,])))
S[i-1] <- max(S1, S2)
theta[i,] <- z
}
iter_nos <- seq(1:iter)
plot(iter_nos, log(S), type = "l")
View(x_tv_denoised)
set.seed(123)
n <- 100  # Number of samples
p <- 5    # Number of features
# Generate predictors (features)
X <- matrix(rnorm(n * p), ncol = p)
# Generate true coefficients
theta_true <- c(3, 2, 1, 0, 0)
# Generate response variable
y <- X %*% theta_true + rnorm(n)
lambda <- 1
iter <- 500
mu <- 1.99/(max(eigen(X%*%t(X))$values) + 0.001)
theta_start <- c(7,5,3,9,1)
theta <- matrix(0, nrow = iter, ncol = length(theta_true))
S <- numeric(length = iter)
grad_fn <- function(mat, data, value)
{
grad = t(mat)%*%(mat%*%value - data)
return(grad)
}
prox_func <- function(u, lambda) {       ####  u is a vector
return(sign(u)*sapply(u, FUN=function(x) {max(abs(x)-lambda,0)}))
}
theta[1,] <- theta_start
for (i in 2:iter)
{
gradval <- grad_fn(X, y, theta[i-1,])
z <- prox_func(theta[i-1,] - mu*gradval, mu*lambda)
S1 <- max(max(abs(gradval)) - lambda, 0)
S2 <- abs(-t(gradval)%*%theta[i-1,] - sum(abs(theta[i-1,])))
S[i-1] <- max(S1, S2)
theta[i,] <- z
}
iter_nos <- seq(1:iter)
plot(iter_nos, log(S), type = "l")
set.seed(123)
n <- 100  # Number of samples
p <- 5    # Number of features
# Generate predictors (features)
X <- matrix(rnorm(n * p), ncol = p)
# Generate true coefficients
theta_true <- c(3, 2, 1, 0, 0)
# Generate response variable
y <- X %*% theta_true + rnorm(n)
lambda <- 1
iter <- 500
mu <- 1.99/(max(eigen(X%*%t(X))$values) + 0.001)
theta_start <- c(7,5,3,9,1)
theta <- matrix(0, nrow = iter, ncol = length(theta_true))
S <- numeric(length = iter)
grad_fn <- function(mat, data, value)
{
grad = t(mat)%*%(mat%*%value - data)
return(grad)
}
prox_func <- function(u, lambda) {       ####  u is a vector
return(sign(u)*sapply(u, FUN=function(x) {max(abs(x)-lambda,0)}))
}
theta[1,] <- theta_start
for (i in 2:iter)
{
gradval <- grad_fn(X, y, theta[i-1,])
z <- prox_func(theta[i-1,] - mu*gradval, mu*lambda)
S1 <- max(max(abs(gradval)) - lambda, 0)
S2 <- abs(-t(gradval)%*%theta[i-1,] - sum(abs(theta[i-1,])))
S[i-1] <- max(S1, S2)
theta[i,] <- z
}
iter_nos <- seq(1:iter)
plot(iter_nos, S, type = "l")
S
set.seed(123)
n <- 100  # Number of samples
p <- 5    # Number of features
# Generate predictors (features)
X <- matrix(rnorm(n * p), ncol = p)
# Generate true coefficients
theta_true <- c(3, 2, 1, 0, 0)
# Generate response variable
y <- X %*% theta_true + rnorm(n)
lambda <- 1
iter <- 500
mu <- 1.99/(max(eigen(X%*%t(X))$values) + 0.001)
theta_start <- c(7,5,3,9,1)
theta <- matrix(0, nrow = iter, ncol = length(theta_true))
S <- numeric(length = iter)
grad_fn <- function(mat, data, value)
{
grad = t(mat)%*%(mat%*%value - data)
return(grad)
}
prox_func <- function(u, lambda) {       ####  u is a vector
return(sign(u)*sapply(u, FUN=function(x) {max(abs(x)-lambda,0)}))
}
theta[1,] <- theta_start
for (i in 2:iter)
{
gradval <- grad_fn(X, y, theta[i-1,])
z <- prox_func(theta[i-1,] - mu*gradval, mu*lambda)
S1 <- max(max(abs(gradval)) - lambda, 0)
S2 <- abs(-t(gradval)%*%theta[i-1,] - sum(abs(theta[i-1,])))
S[i-1] <- max(S1, S2)
theta[i,] <- z
}
iter_nos <- seq(1:iter)
plot(iter_nos, log(S), type = "l")
set.seed(123)
n <- 100  # Number of samples
p <- 5    # Number of features
# Generate predictors (features)
X <- matrix(rnorm(n * p), ncol = p)
# Generate true coefficients
theta_true <- c(3, 2, 1, 0, 0)
# Generate response variable
y <- X %*% theta_true + rnorm(n)
lambda <- 1
iter <- 500
mu <- 1.99/(max(eigen(X%*%t(X))$values) + 0.001)
theta_start <- c(7,5,3,9,1)
theta <- matrix(0, nrow = iter, ncol = length(theta_true))
S <- numeric(length = iter)
grad_fn <- function(mat, data, value)
{
grad = t(mat)%*%(mat%*%value - data)
return(grad)
}
prox_func <- function(u, lambda) {       ####  u is a vector
return(sign(u)*sapply(u, FUN=function(x) {max(abs(x)-lambda,0)}))
}
theta[1,] <- theta_start
for (i in 2:iter)
{
gradval <- grad_fn(X, y, theta[i-1,])
z <- prox_func(theta[i-1,] - mu*gradval, mu*lambda)
S1 <- max(max(abs(gradval)) - lambda, 0)
S2 <- abs(-t(gradval)%*%theta[i-1,] - sum(abs(theta[i-1,])))
S[i-1] <- max(S1, S2)
theta[i,] <- z
}
iter_nos <- seq(1:iter)
plot(iter_nos, S, type = "l")
source("nuclear_norm_functions.R")
setwd("~/Documents/GitHub/Proximal_IS/Poisson_random_effects_model")
rm(list = ls())
source("Poisson_functions.R")
load("output_single_mala.Rdata")
load("output_single_bark.Rdata")
load("output_single_hmc.Rdata")
load("output_poisson.Rdata")
acf_is_hmc <- acf(output_chain_hmc[[1]][,1], plot = FALSE, lag.max = lag.max)$acf
dim <- 51
lag.max <- 50
acf_is_hmc <- acf(output_chain_hmc[[1]][,1], plot = FALSE, lag.max = lag.max)$acf
acf_pxhmc <- acf(output_chain_hmc[[2]][,1], plot = FALSE, lag.max = lag.max)$acf
diff.acf <- matrix(0, ncol = dim, nrow = lag.max + 1)
diff.acf[,1] <- acf_is_hmc - acf_pxhmc
for (i in 2:dim)
{
acf_is_hmc <- acf(output_chain_hmc[[1]][,i], plot = FALSE, lag.max = lag.max)$acf
acf_pxhmc <- acf(output_chain_hmc[[2]][,i], plot = FALSE, lag.max = lag.max)$acf
diff.acf[,i] <- acf_is_hmc - acf_pxhmc
}
# Make boxplot of ACFs
boxplot(t(diff.acf),
xlab = "Lags", ylab = "Difference in ACF (MYHMC - PxHMC)",ylim = c(-1, 1))
dim <- 51
lag.max <- 50
acf_is_hmc <- acf(output_chain_hmc[[1]][,1], plot = FALSE, lag.max = lag.max)$acf
acf_pxhmc <- acf(output_chain_hmc[[2]][,1], plot = FALSE, lag.max = lag.max)$acf
diff.acf <- matrix(0, ncol = dim, nrow = lag.max + 1)
diff.acf[,1] <- acf_is_hmc - acf_pxhmc
for (i in 2:dim)
{
acf_is_hmc <- acf(output_chain_hmc[[1]][,i], plot = FALSE, lag.max = lag.max)$acf
acf_pxhmc <- acf(output_chain_hmc[[2]][,i], plot = FALSE, lag.max = lag.max)$acf
diff.acf[,i] <- acf_is_hmc - acf_pxhmc
}
# Make boxplot of ACFs
boxplot(t(diff.acf),
xlab = "Lags", ylab = "Difference in ACF (MYHMC - PxHMC)",ylim = c(-.6, .1))
acf_ism <- acf(output_chain_mala[[1]][,1], plot = FALSE, lag.max = lag.max)$acf
acf_pxm <- acf(output_chain_mala[[2]][,1], plot = FALSE, lag.max = lag.max)$acf
diff.acf <- matrix(0, ncol = dim, nrow = lag.max + 1)
diff.acf[,1] <- acf_ism - acf_pxm
for (i in 2:dim)
{
acf_ism <- acf(output_chain_mala[[1]][,i], plot = FALSE,lag.max = lag.max)$acf
acf_pxm <- acf(output_chain_mala[[2]][,i], plot = FALSE,lag.max = lag.max)$acf
diff.acf[,i] <- acf_ism - acf_pxm
}
# Make boxplot of ACFs
boxplot(t(diff.acf),
xlab = "Lags", ylab = "Difference in ACF (MYMala - PxMala)",ylim = c(-.6, .1))
################################################################################
################## Poisson example output visualisation ########################
################################################################################
rm(list = ls())
source("Poisson_functions.R")
load("output_single_mala.Rdata")
load("output_single_bark.Rdata")
load("output_single_hmc.Rdata")
load("output_poisson.Rdata")
################ ACF plots ################
dim <- 51
pdf("plots/acf_poisson_present.pdf", height = 6, width = 12)
par(mfrow = c(1,3))
################## MALA  #####################
lag.max <- 50
acf_ism <- acf(output_chain_mala[[1]][,1], plot = FALSE, lag.max = lag.max)$acf
acf_pxm <- acf(output_chain_mala[[2]][,1], plot = FALSE, lag.max = lag.max)$acf
diff.acf <- matrix(0, ncol = dim, nrow = lag.max + 1)
diff.acf[,1] <- acf_ism - acf_pxm
for (i in 2:dim)
{
acf_ism <- acf(output_chain_mala[[1]][,i], plot = FALSE,lag.max = lag.max)$acf
acf_pxm <- acf(output_chain_mala[[2]][,i], plot = FALSE,lag.max = lag.max)$acf
diff.acf[,i] <- acf_ism - acf_pxm
}
# Make boxplot of ACFs
boxplot(t(diff.acf),
xlab = "Lags", ylab = "Difference in ACF (MYMala - PxMala)",ylim = c(-.6, .1))
################## Barker  #####################
acf_isb <- acf(output_chain_bark[[1]][,1], plot = FALSE, lag.max = lag.max)$acf
acf_pxb <- acf(output_chain_bark[[2]][,1], plot = FALSE, lag.max = lag.max)$acf
diff.acf <- matrix(0, ncol = dim, nrow = lag.max + 1)
diff.acf[,1] <- acf_isb - acf_pxb
for (i in 2:dim)
{
acf_isb <- acf(output_chain_bark[[1]][,i], plot = FALSE, lag.max = lag.max)$acf
acf_pxb <- acf(output_chain_bark[[2]][,i], plot = FALSE, lag.max = lag.max)$acf
diff.acf[,i] <- acf_isb - acf_pxb
}
# Make boxplot of ACFs
boxplot(t(diff.acf),
xlab = "Lags", ylab = "Difference in ACF (MYBarker - PxBarker)",ylim = c(-.6, .1))
dev.off()
################ ACF plots ################
dim <- 51
pdf("plots/acf_poisson_present.pdf", height = 6, width = 12)
par(mfrow = c(1,2))
################## MALA  #####################
lag.max <- 50
acf_ism <- acf(output_chain_mala[[1]][,1], plot = FALSE, lag.max = lag.max)$acf
acf_pxm <- acf(output_chain_mala[[2]][,1], plot = FALSE, lag.max = lag.max)$acf
diff.acf <- matrix(0, ncol = dim, nrow = lag.max + 1)
diff.acf[,1] <- acf_ism - acf_pxm
for (i in 2:dim)
{
acf_ism <- acf(output_chain_mala[[1]][,i], plot = FALSE,lag.max = lag.max)$acf
acf_pxm <- acf(output_chain_mala[[2]][,i], plot = FALSE,lag.max = lag.max)$acf
diff.acf[,i] <- acf_ism - acf_pxm
}
# Make boxplot of ACFs
boxplot(t(diff.acf),
xlab = "Lags", ylab = "Difference in ACF (MYMala - PxMala)",ylim = c(-.6, .1))
################## Barker  #####################
acf_isb <- acf(output_chain_bark[[1]][,1], plot = FALSE, lag.max = lag.max)$acf
acf_pxb <- acf(output_chain_bark[[2]][,1], plot = FALSE, lag.max = lag.max)$acf
diff.acf <- matrix(0, ncol = dim, nrow = lag.max + 1)
diff.acf[,1] <- acf_isb - acf_pxb
for (i in 2:dim)
{
acf_isb <- acf(output_chain_bark[[1]][,i], plot = FALSE, lag.max = lag.max)$acf
acf_pxb <- acf(output_chain_bark[[2]][,i], plot = FALSE, lag.max = lag.max)$acf
diff.acf[,i] <- acf_isb - acf_pxb
}
# Make boxplot of ACFs
boxplot(t(diff.acf),
xlab = "Lags", ylab = "Difference in ACF (MYBarker - PxBarker)",ylim = c(-.6, .1))
dev.off()
load("output_poisson.Rdata")
output_poisson[[40]][[8]]
output_poisson[[40]][[9]]
output_poisson[[40]][[10]]
output_poisson[[47]][[10]]
pdf("plots/acf_poisson.pdf", height = 6, width = 12)
par(mfrow = c(1,3))
acf_isb <- acf(output_chain_bark[[1]][,1], plot = FALSE, lag.max = lag.max)$acf
acf_trub <- acf(output_chain_bark[[3]][,1], plot = FALSE, lag.max = lag.max)$acf
diff.acf <- matrix(0, ncol = dim, nrow = lag.max + 1)
diff.acf[,1] <- acf_isb - acf_trub
for (i in 2:dim)
{
acf_isb <- acf(output_chain_bark[[1]][,i], plot = FALSE, lag.max = lag.max)$acf
acf_trub <- acf(output_chain_bark[[3]][,i], plot = FALSE, lag.max = lag.max)$acf
diff.acf[,i] <- acf_isb - acf_trub
}
# Make boxplot of ACFs
boxplot(t(diff.acf),
xlab = "Lags", ylab = "Difference in ACF (MYBarker - Barker)",ylim = c(-.6, .1))
acf_isb <- acf(output_chain_bark[[1]][,1], plot = FALSE, lag.max = lag.max)$acf
acf_trub <- acf(output_chain_bark[[3]][,1], plot = FALSE, lag.max = lag.max)$acf
diff.acf <- matrix(0, ncol = dim, nrow = lag.max + 1)
diff.acf[,1] <- acf_isb - acf_trub
for (i in 2:dim)
{
acf_isb <- acf(output_chain_bark[[1]][,i], plot = FALSE, lag.max = lag.max)$acf
acf_trub <- acf(output_chain_bark[[3]][,i], plot = FALSE, lag.max = lag.max)$acf
diff.acf[,i] <- acf_isb - acf_trub
}
# Make boxplot of ACFs
boxplot(t(diff.acf),
xlab = "Lags", ylab = "Difference in ACF (MYBarker - Barker)",ylim = c(-.6, .1))
acf_isb <- acf(output_chain_bark[[1]][,1], plot = FALSE, lag.max = lag.max)$acf
acf_trub <- acf(output_chain_bark[[3]][,1], plot = FALSE, lag.max = lag.max)$acf
diff.acf <- matrix(0, ncol = dim, nrow = lag.max + 1)
diff.acf[,1] <- acf_isb - acf_trub
for (i in 2:dim)
{
acf_isb <- acf(output_chain_bark[[1]][,i], plot = FALSE, lag.max = lag.max)$acf
acf_trub <- acf(output_chain_bark[[3]][,i], plot = FALSE, lag.max = lag.max)$acf
diff.acf[,i] <- acf_isb - acf_trub
}
# Make boxplot of ACFs
boxplot(t(diff.acf),
xlab = "Lags", ylab = "Difference in ACF (MYBarker - Barker)",ylim = c(-.6, .1))
################################################################################
################## Poisson example output visualisation ########################
################################################################################
rm(list = ls())
source("Poisson_functions.R")
load("output_single_mala.Rdata")
load("output_single_bark.Rdata")
load("output_single_hmc.Rdata")
load("output_poisson.Rdata")
################ ACF plots ################
dim <- 51
lag.max <- 50
acf_isb <- acf(output_chain_bark[[1]][,1], plot = FALSE, lag.max = lag.max)$acf
acf_trub <- acf(output_chain_bark[[3]][,1], plot = FALSE, lag.max = lag.max)$acf
diff.acf <- matrix(0, ncol = dim, nrow = lag.max + 1)
diff.acf[,1] <- acf_isb - acf_trub
for (i in 2:dim)
{
acf_isb <- acf(output_chain_bark[[1]][,i], plot = FALSE, lag.max = lag.max)$acf
acf_trub <- acf(output_chain_bark[[3]][,i], plot = FALSE, lag.max = lag.max)$acf
diff.acf[,i] <- acf_isb - acf_trub
}
# Make boxplot of ACFs
boxplot(t(diff.acf),
xlab = "Lags", ylab = "Difference in ACF (MYBarker - Barker)",ylim = c(-.6, .1))
acf_ism <- acf(output_chain_mala[[1]][,1], plot = FALSE, lag.max = lag.max)$acf
acf_pxm <- acf(output_chain_mala[[2]][,1], plot = FALSE, lag.max = lag.max)$acf
diff.acf <- matrix(0, ncol = dim, nrow = lag.max + 1)
diff.acf[,1] <- acf_ism - acf_pxm
for (i in 2:dim)
{
acf_ism <- acf(output_chain_mala[[1]][,i], plot = FALSE,lag.max = lag.max)$acf
acf_pxm <- acf(output_chain_mala[[2]][,i], plot = FALSE,lag.max = lag.max)$acf
diff.acf[,i] <- acf_ism - acf_pxm
}
# Make boxplot of ACFs
boxplot(t(diff.acf),
xlab = "Lags", ylab = "Difference in ACF (MYMala - PxMala)",ylim = c(-.6, .1))
acf_is_hmc <- acf(output_chain_hmc[[1]][,1], plot = FALSE, lag.max = lag.max)$acf
acf_pxhmc <- acf(output_chain_hmc[[2]][,1], plot = FALSE, lag.max = lag.max)$acf
diff.acf <- matrix(0, ncol = dim, nrow = lag.max + 1)
diff.acf[,1] <- acf_is_hmc - acf_pxhmc
for (i in 2:dim)
{
acf_is_hmc <- acf(output_chain_hmc[[1]][,i], plot = FALSE, lag.max = lag.max)$acf
acf_pxhmc <- acf(output_chain_hmc[[2]][,i], plot = FALSE, lag.max = lag.max)$acf
diff.acf[,i] <- acf_is_hmc - acf_pxhmc
}
# Make boxplot of ACFs
boxplot(t(diff.acf),
xlab = "Lags", ylab = "Difference in ACF (MYHMC - PxHMC)",ylim = c(-.6, .1))
